## Тема 9. TCL, DCL.

### 1. Транзакции

#### 1.1. Теоретическая справка

**Транзакция** – это объект, группирующий последовательность операций, которые должны быть выполнены как единое целое.
Обеспечивает переход БД из одного целостного состояния в другое.

![](img/img.png)

В качестве примера транзакции рассмотрим последовательность операций по приему заказа в коммерческой компании. Для
приема заказа от клиента приложение ввода заказов должно:

* выполнить запрос к таблице товаров и проверить наличие товара на складе;
* добавить заказ к таблице счетов;
* обновить таблицу товаров, вычтя заказанное количество товаров из количества товара, имеющегося в наличии;
* обновить таблицу продаж, добавив стоимость заказа к объему продаж служащего, принявшего заказ;
* обновить таблицу офисов, добавив стоимость заказа к объему продаж офиса, в котором работает данный служащий.

Транзакции обеспечивают целостность БД в условиях:

* Параллельной обработки данных
* Физических отказов диска
* Аварийного сбоя электропитания
* И других

Транзакции обладают 4 характеристиками, удовлетворяющими парадигме ACID:

1. Atomic – атомарные;
2. Consistent – согласованные;
3. Isolated – изолированные;
4. Durable – долговечные, устойчивые.

#### <ins>A</ins>CID – Атомарность транзакций (Atomicity)

* Транзакция должна представлять собой атомарную (неделимую) единицу работы;
* Должны быть выполнены либо все операции, входящие в транзакцию, либо ни одна из них;
* Следовательно, в случае невозможности выполнить все операции, все внесённые изменения должны быть отменены:
    * Commit – совершение транзакции
    * Rollback – отмена транзакции

#### A<ins>C</ins>ID – Согласованность транзакций (Consistency)

* По завершению транзакции все данные должны остаться в согласованном состоянии
* При выполнении транзакции необходимо выполнить все правила реляционной СУБД:
    * Проверки выполнения ограничений (домены, индексы уникальности, внешние ключи, проверки, правила и т.д.)
    * Обновление индексов;
    * Выполнение триггеров
    * И другие

#### AC<ins>I</ins>D – Изоляция транзакций (Isolation)

* Изменения в данных, выполняемые в пределах транзакции, должны быть изолированы от всех изменений, выполняемых в других
  транзакциях, до тех пор, пока транзакция не совершена;
* Выделяют различные уровни изоляции – для достижения компромисса между степенью распараллеливания работы с БД и
  строгостью выполнения принципа непротиворечивости:
    * Чем выше уровень изоляции, тем выше степень непротиворечивости данных;
    * Чем выше уровень изоляции, тем ниже степень распараллеливания и тем ниже степень доступности данных.

Стандартная классификация проблем с уровнями изоляции:

* P1: dirty read – «грязное» чтение
* P2: non-repeatable read – невоспроизводимое чтение
* P3: phantom read – фантомное чтение

**P1 (dirty read, «грязное» чтение)**

1. Транзакция Т1 вносит изменения в ряд таблицы.
2. Т2 читает этот ряд после внесения изменений Т1, но до совершения Т1.
3. Если Т1 будет отменена, то данные, считанные Т2, будут некорректными.

```postgresql
-- T1
UPDATE Users
SET AGE = 21
WHERE Id = 1;

ROLLBACK;
```

```postgresql
-- T2
SELECT Age
FROM Users
WHERE Id = 1;
```

**P2 (non-repeatable read, невоспроизводимое чтение)**

1. Транзакция Т1 читает ряд.
2. Транзакция Т2 после этого вносит изменения в этот ряд или удаляет его.
3. Если Т1 после этого считает этот же ряд снова, то получит новый результат по сравнению с первым считыванием.

```postgresql
-- T1
SELECT *
FROM Users
WHERE Id = 1;
```

```postgresql
-- T2
UPDATE Users
SET AGE = 21
WHERE Id = 1;

COMMIT;
```

**P3 (phantom, фантомное чтение)**

1. Транзакция Т1 читает набор рядов N, удовлетворяющих некоторому условию.
2. После этого Т2 выполняет SQL запросы, создающие новые ряды, удовлетворяющие этому условию.
3. Если Т1 повторит запрос с тем же условием, то получит другой набор рядов.

```postgresql
-- T1
SELECT *
FROM Users
WHERE Age BETWEEN 10 AND 30;
```

```postgresql
-- T2
INSERT INTO Users (Name, Age)
VALUES (‘Bob’, 27);

COMMIT;
```

#### ACI<ins>D</ins> – Долговечность, устойчивость (прочность) транзакций (Durability)

* Если транзакия была совершена, её результат должен сохраниться в системе, несмотря на сбой системы;
* Если транзакиция не была совершена, её результат может быть полностью отменён вслед за сбоем системы.

#### 1.2. Transaction Control Language

```postgresql
BEGIN TRANSACTION transaction_mode [, ...]
   ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }
   READ WRITE | READ ONLY
   [NOT] DEFERRABLE

BEGIN / START
   COMMIT
   ROLLBACK

SAVEPOINT name
   ROLLBACK TO SAVEPOINT name
   RELEASE SAVEPOINT name
```

**Границы транзакций**

```postgresql
BEGIN;
INSERT ...;
UPDATE ...;
DELETE ...;
COMMIT;

BEGIN;
INSERT ...;
UPDATE ...;
DELETE ...;
ROLLBACK;
```

#### 1.3. Уровни изолированности транзакций ANSI SQL

В идеальном мире параллельные транзакции изолированны (идеально уживаются друг с другом в базе), но в реальном мире
такое невозможно. Характеристика соответствия базы свойству изолированности называется уровнем изолированности. Выделяют
4 уровня изолированности:

![](img/img_1.png)

* **READ UNCOMMITTED**: помогает бороться с потерянными обновлениями при изменениях одного и того же блока данных
  несколькими транзакциями.
* **READ COMMITTED**: помогает бороться с чтением "грязных" данных, измененных впоследствии откатившейся транзакцией
* **REPEATABLE READ**: помогает бороться с изменением в данных при повторном чтении одного и того же блока данных в
  рамках одной транзакции
* **SERIALIZABLE**: аналогично **REPEATABLE READ**, но применимо к `INSERT`, а не `UPDATE`

---

### 2. Практическое задание (TCL)

1. Создать схему topic_9:

```postgresql
CREATE SCHEMA topic_9;
```

2. Создать таблицу:

```postgresql
CREATE TABLE topic_9.test_table (
    my_id         SERIAL,
    my_text_filed TEXT
);
```

3. Открыть новую транзакцию в явном виде. Запустить операцию вставки

```postgresql
INSERT INTO topic_9.test_table (my_text_filed) VALUES (’test_value1’);
```

Не завершая транзакцию, проверить, что данные в таблицу вставились. Обратить внимание на значение в поле `my_id`.

4. В новой консоли написать запрос на получение всех строк таблицы, созданной в п.2. Объясните, почему так вышло.
   Закоммитьте изменения в консоли 1.

5. В обеих консолях откройте новые транзакции.

* Напишите в первой консоли апдейт к единственной строке таблицы. Проверьте, что первая транзакция видит изменения.
* Во второй консоли запустите операцию апдейта к той же строке. Подумайте, что произошло и почему?
* Сохраните изменения в первой консоли. Что произошло со второй консолью?
* Сохраните изменения во второй консоли.

6. Повторите предыдущее упражнение с использованием уровня repeatable read. Что произошло при попытке закоммитить
   изменения первой открытой транзакцией? Откатите обе транзакции.

7. Для получения дефолтного значения уровня изолированности транзакций в вашем постгрес воспользуйтесь командой:

```postgresql
SHOW default_transaction_isolation;
```

Объясните разницу в поведении транзакций в задачах 6 и 7, воспользовавшись новым знанием.

8. Повторите задачу 5, используя оператор вставки данных, а не обновления, по аналогии с п.3. Посмотрите на значение в
   поле `my_id` после вставки второй транзакцией.

9. В обеих консолях откройте новые транзакции уровня serializable

* Первой транзакцией считайте данные из таблицы.
* Второй транзакцией осуществите вставку в таблицу новых данных. И сразу же примените изменения.
* Снова считайте данные первой транзакцией. Что произошло?
* Попробуйте добавить в таблицу данные с использованием первой транзакции. Что произошло? Откатите изменения.

10. Откройте новую транзакцию в любой консоли, уровень изолированности не имеет значения.

* Добавьте в таблицу несколько строк.
* Создайте точку останова (savepoint) и посмотрите на значения в таблице.
* Снова добавьте в таблицу несколько строк, создайте точку останова и посмотрите на строки в таблице.
* Добавьте в таблицу еще одну строк и посмотрите на таблицу.
* Откатитесь ко второй точке останова и посмотрите на данные.
* Откатитесь к первой точке останова и посмотрите на данные.
* Откатите всю транзакцию.


---

### 3. Разграничение доступов PostgreSQL.

#### 3.1. Пользователи и роли

**Роль** – множество пользователей БД
* Может владеть объектами в базе
* Может иметь определенный доступ к некоторым объектам базы, не являясь их владельцем
* Может выдавать доступы на некоторые объекты в базе другим ролям
* Может предоставлять членство в роли другой роли

**Создание пользователя**

```sql
CREATE USER == CREATE ROLE

CREATE USER name [[WITH] option [...]]
where option can be:
SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE
| INHERIT | NOINHERIT
| LOGIN | NOLOGIN
| REPLICATION | NOREPLICATION
| BYPASSRLS | NOBYPASSRLS
| CONNECTION LIMIT connlimit
| [ENCRYPTED] PASSWORD 'password' | PASSWORD NULL
| VALID UNTIL 'timestamp'
| IN ROLE role_name [, ...]
| IN GROUP role_name [, ...]
| ROLE role_name [, ...]
| ADMIN role_name [, ...]
| USER role_name [, ...]
| SYSID uid
```

```sql
CREATE ROLE jonathan LOGIN;

CREATE USER davide
WITH PASSWORD 'jw8s0F4';

CREATE ROLE Miriam
WITH LOGIN PASSWORD 'jw8s0F4'
VALID UNTIL '2005-01-01';
```

#### 3.2. Data Control Language (DCL)

* Позволяет настраивать доступы к объектам
* Поддерживает 2 типа действий:
    * `GRANT` – выдача доступа к объекту
    * `REVOKE` – отмена доступа к объекту

**Права, которые можно выдать на объект:**
* `SELECT`
* `INSERT`
* `UPDATE`
* `DELETE`
* `TRUNCATE`
* `REFERENCES`
* `TRIGGER`
* `CREATE`
* `CONNECT`
* `TEMPORARY`
* `EXECUTE`
* `USAGE`

[**GRANT ON TABLE**](https://postgrespro.ru/docs/postgresql/9.6/sql-grant)
```sql
GRANT {{SELECT | INSERT | UPDATE | DELETE | TRUNCATE |
    REFERENCES | TRIGGER}
[, ...] | ALL [PRIVILEGES]}
ON {[ TABLE] table_name [, ...]
    | ALL TABLES IN SCHEMA schema_name [, ...]}
TO role_specification [, ...] [WITH GRANT OPTION]
```

[**REVOKE ON TABLE**](https://postgrespro.ru/docs/postgresql/9.6/sql-revoke)

```sql
REVOKE [GRANT OPTION FOR]
    {{SELECT | INSERT | UPDATE | DELETE | TRUNCATE |
        REFERENCES | TRIGGER}
[, ...] | ALL [PRIVILEGES]}
ON {[TABLE] table_name [, ...]
    | ALL TABLES IN SCHEMA schema_name [, ...]}
FROM {[GROUP] role_name | PUBLIC} [, ...]
[CASCADE | RESTRICT]
```

```sql
GRANT ALL PRIVILEGES ON kinds TO manuel;
REVOKE ALL PRIVILEGES ON kinds FROM manuel;

GRANT SELECT ON kinds TO manuel WITH GRANT OPTION; -- manuel может выдавать права на SELECT на табличку kinds
```

*Примечание:* Если мы хотим забрать `grant option` у `manuel`, то нужно использовать `CASCADE`, чтобы забрать права у всех, кому он выдавал права. Иначе при попытке отозвать права у `manuel`, запрос упадет с ошибкой.

**Примеры использования:**

```sql
CREATE USER davide WITH PASSWORD 'jw8s0F4';

GRANT CONNECT ON DATABASE db_prod TO davide;

GRANT USAGE ON SCHEMA my_schema TO davide;

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA my_schema
TO davide;
```
