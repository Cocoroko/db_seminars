## Тема 7. CTE, Views.

### 1. Теоретическая справка

#### 1.1. Общие табличные выражения (CTE).

**Запросы WITH (Общие табличные выражения):**

**CTE (Common Table Expression)** (синоним к подзапросу; живет ровно в момент исполнения одного конкретного запроса) — именованный временный набор данных, используемый в запросе.

`WITH` предоставляет способ записывать дополнительные операторы для применения в больших запросах. Эти операторы,
которые также называют общими табличными выражениями (Common Table Expressions, CTE), можно представить как определения
временных таблиц, существующих только для одного запроса. Дополнительным оператором в предложении `WITH` может быть
`SELECT`, `INSERT`, `UPDATE` или `DELETE`, а само предложение `WITH` присоединяется к основному оператору, которым также
может быть `SELECT`, `INSERT`, `UPDATE` или `DELETE`.

Синтаксис:

```postgresql
WITH [RECURSIVE] cte_query_name
    AS (cte_query)
main_query;
```

Это способ задания временного набора результатов для использования в инструкциях DML.

Позволяет:

* Упростить запрос
* Реализовать рекурсивные запросы

Пример:

```postgresql
WITH 
    regional_sales AS (
        SELECT 
            region, 
            SUM(amount) AS total_sales
        FROM 
            orders
        GROUP BY 
            region
    ),
    top_regions AS (
        SELECT 
            region
        FROM 
            regional_sales
        WHERE 
            total_sales > (SELECT SUM(total_sales) / 10 FROM regional_sales)
    )
SELECT 
    region, 
    product, 
    SUM(quantity) AS product_units, 
    SUM(amount) AS product_sales
FROM 
    orders
WHERE 
    region IN (SELECT region FROM top_regions)
GROUP BY 
    region, 
    product;
```

выводит итоги по продажам только для передовых регионов. Предложение `WITH` определяет два дополнительных оператора
`regional_sales` и `top_regions` так, что результат `regional_sales` используется в `top_regions`, а
результат `top_regions` используется в основном запросе `SELECT`. Этот пример можно было бы переписать без `WITH`, но
тогда нам понадобятся два уровня вложенных подзапросов `SELECT`. Показанным выше способом это можно сделать немного
проще.

**Рекурсивные запросы**

Необязательное указание `RECURSIVE` превращает `WITH` из просто удобной синтаксической конструкции в средство реализации
того, что невозможно в стандартном `SQL`. Используя `RECURSIVE`, запрос `WITH` может обращаться к собственному
результату.

**Синтаксис:**

```postgresql
with recursive <cte_name> (<parameters>) as (
	<recursive base>    -- Нерекурсивное выражение
	union all           -- UNION или UNION ALL
	<recursion step>    -- Рекурсивное выражение, может ссылаться на результат запроса
)
<main query>;
```

**Примеры:**

1. Запрос на получение суммы целых чисел от 1 до 100:

```postgresql
WITH RECURSIVE t(n) AS (
    VALUES (1)      -- данные, для которых рекурсия не нужна
    
    UNION ALL
    
    SELECT 
        n + 1    -- рекурсивная часть
    FROM 
        t
    WHERE 
        n < 100
)
SELECT 
    sum(n)
FROM 
    t;
```

2. Запрос на вывод чисел Фибоначчи

```postgresql
WITH RECURSIVE fib(n1, n2) AS (
    VALUES(0, 1) 		            -- данные, для которых рекурсия не нужна
   
    UNION ALL
   	
    SELECT 
        greatest(n1, n2), n1 + n2 -- рекурсивная часть
    FROM 
        fib
    WHERE 
        n2 < 100
)
SELECT 
    n1 
FROM 
    fib;
```


> **Примечание!**
>
> Строго говоря, этот процесс является итерационным, а не рекурсивным,
> но комитетом по стандартам `SQL` был выбран термин `RECURSIVE`.

**Вычисление рекурсивного CTE:**

1. Определить значение нерекурсивного выражения. Если указан `UNION`, то отбросить ряды-дубликаты. Поместить оставшиеся
   ряды в результат рекурсивного запроса, а также во временную рабочую таблицу
2. До тех пор, пока временная таблица не пустая:
    1. Определить значение реурсивного выражения, заменив текущее содержимое рабочей таблицы рекурсивной ссылкой на
       себя. Если указан `UNION`, то отбросить ряды-дубликаты. Включить все оставшиеся ряды в результат рекурсивного
       запроса, а также во временную таблицу
    2. Заменить содержимое рабочей таблицы содержимым промежуточной таблицы и очистить промежуточную таблицу

Рекурсивные запросы обычно применяются для работы с иерархическими или древовидными структурами данных. В качестве
полезного примера можно привести запрос, находящий все непосредственные и косвенные составные части продукта, используя
только таблицу с прямыми связями:

```postgresql
WITH RECURSIVE 
    included_parts(sub_part, part, quantity) AS (
        SELECT 
            sub_part, 
            part, 
            quantity
        FROM 
            parts
        WHERE 
            part = 'our_product'
        
        UNION ALL
        
        SELECT 
            p.sub_part, 
            p.part, 
            p.quantity
        FROM 
            included_parts pr,
            parts p
        WHERE 
            p.part = pr.sub_part
    )
SELECT 
    sub_part, 
    SUM(quantity) AS total_quantity
FROM 
    included_parts
GROUP BY 
    sub_part;
```

**Изменение данных в WITH:**
```postgresql
WITH moved_rows AS (
    DELETE FROM 
        products
    WHERE
        date >= '2010-10-01' AND
        date < '2010-11-01'
    RETURNING *
)
INSERT INTO products_log SELECT * FROM moved_rows;
```

Этот запрос фактически перемещает строки из `products` в `products_log`. Оператор `DELETE` в `WITH` удаляет указанные
строки из products и возвращает их содержимое в предложении `RETURNING`; а затем главный запрос читает это содержимое и
вставляет в таблицу `products_log`.

Следует заметить, что предложение `WITH` в данном случае присоединяется к оператору `INSERT`, а не к `SELECT`,
вложенному в `INSERT`. Это необходимо, так как `WITH` может содержать операторы, изменяющие данные, только на верхнем
уровне запроса. Однако при этом применяются обычные правила видимости `WITH`, так что к результату `WITH` можно
обратиться и из вложенного оператора `SELECT`.

Операторы, изменяющие данные, в `WITH` обычно дополняются предложением `RETURNING`[^2], как показано в этом примере.
Важно понимать, что временная таблица, которую можно будет использовать в остальном запросе, создаётся из
результата `RETURNING`, а не целевой таблицы оператора. Если оператор, изменяющий данные, в `WITH` не дополнен
предложением `RETURNING`, временная таблица не создаётся и обращаться к ней в остальном запросе нельзя. Однако такой
запрос всё равно будет выполнен. Например, допустим следующий не очень практичный запрос:

```sql
WITH 
    t AS (
        DELETE FROM foo
    )
DELETE FROM bar;
```

Он удалит все строки из таблиц `foo` и `bar`. При этом число задействованных строк, которое получит клиент, будет
подсчитываться только по строкам, удалённым из `bar`.

#### 1.2. Представления (Views).

**Представления (Views):** – это виртуальная таблица, содержимое которой (столбцы и строки) определяется запросом.

**Представление** — это виртуальная (логическая) таблица, представляющая собой  поименованный запрос (синоним к запросу), который будет подставлен как подзапрос при использовании представления. Используется, если необходимо часто делать какой-то запрос со сложной логикой.

* Не является самостоятельной частью набора данных
* Вычисляется динамически на основании данных, хранящихся в реальных таблицах
* Изменение данных в таблицах немедленно отражается в содержимом представлений

Представление можно использовать в следующих целях:
* Для направления, упрощения и настройки восприятия информации в базе данных каждым пользователем.
* В качестве механизма безопасности, позволяющего пользователям обращаться к данным через представления, но не дающего
  им разрешений на непосредственный доступ к базовым таблицам.

**Достоинства:**
* *Безопасность:* можно искусственно ограничивать информацию, к которой у пользователя есть доступ.
* *Простота запросов:* при написании запросов обращаемся к вью, как и к обычной таблице.
* *Защита от изменений:* пользователю не обязательно знать, что структуры / имена таблиц поменялись. Достаточно обновить представление.

**Недостатки:**
* *Производительность:* кажущийся простым запрос с использованием вью на деле может оказаться очень сложным из-за логики, “зашитой” во вью.
* *Управляемость:* вью может быть основана на вью, которая в свою очередь тоже основана на другой вью и т.д.
* *Ограничение на обновление:** не любую вью можно обновить, что не всегда очевидно пользователю.

**Синтаксис:**

```sql
CREATE
[ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] 
  VIEW name [ ( column_name [, ...] ) ]
  [
WITH (view_option_name [= view_option_value] [, ...]) ]
  AS query
  [
WITH [ CASCADED | LOCAL ] CHECK
OPTION ]
```

* `CREATE VIEW` – создание нового представления.
* `CREATE OR REPLACE VIEW` – создание или замена уже существующего представления.
    * В случае замены в новом представлении должны присутствовать все поля старого представления (имена, порядок, тип данных). Допустимо только добавление новых полей.
* `TEMPORARY | TEMP` – временное представление, будет существовать до конца сессии.
* *view_name* – название представления.
* *column_name* – список полей представления. Если не указан, используются поля запроса.
* *query* – `SELECT` или `VALUES` команды.

[Изменения представления](https://www.postgresql.org/docs/current/sql-alterview.html):

```sql
ALTER VIEW [IF EXISTS] name ALTER [COLUMN] column_name SET DEFAULT
expression
ALTER VIEW [IF EXISTS] name ALTER [COLUMN] column_name DROP DEFAULT
ALTER VIEW [IF EXISTS] name OWNER TO new_owner
ALTER VIEW [IF EXISTS] name RENAME TO new_name
ALTER VIEW [IF EXISTS] name SET SCHEMA new_schema
ALTER VIEW [IF EXISTS] name SET ( view_option_name [=
view_option_value] [, ... ] )
ALTER VIEW [IF EXISTS] name RESET ( view_option_name [, ... ] )
DROP VIEW [IF EXISTS] name [, ...] [ CASCADE | RESTRICT ]
```

Примеры:

1. Создание представления

```sql
CREATE VIEW greeting AS
SELECT 'Hello World';

CREATE VIEW greeting AS
SELECT text 'Hello World' AS hello;


CREATE VIEW comedies AS
SELECT 
    *
FROM 
    films
WHERE 
    kind = 'Comedy';
```

Если после создания представления добавить столбцы в таблицу, в представлении их не будет.

**TEMP или TEMPORARY**

Представление создаётся как временное. Удаляется при окончании сессии

```sql
CREATE TEMP VIEW greeting AS
SELECT 'Hello World';
```

**RECURSIVE**

Представление создаётся как рекурсивное. Эквивалентные формы:

```sql
CREATE RECURSIVE VIEW [ schema.
] view_name (column_names
) AS
SELECT ...;
```

```sql
CREATE VIEW [ schema.
] view_name AS
WITH RECURSIVE view_name (column_names) AS (SELECT ...)
SELECT column_names
FROM view_name;
```

Рекурсивное представление – пример:

```sql
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
VALUES (1)
UNION ALL
SELECT
    n + 1
FROM 
    nums_1_100
WHERE 
    n < 100;
```

**Типы представлений:**
1. *горизонтальное* — ограничение данных по строкам:
```sql
CREATE VIEW V_IT_EMPLOYEE AS
SELECT 
    *
FROM 
    EMPLOYEE
WHERE 
    DEPARTMENT_NM = ‘IT’;
```

2. *вертикальное* — ограничение данных по столбцам:
```sql
CREATE VIEW V_EMP AS
SELECT 
    EMP_NM, 
    DEPARTMENT_NM
FROM 
    EMPLOYEE;
```

**Обновляемые представления**

Представление называется *обновляемым*, если к нему применимы операции `UPDATE` и `DELETE` для изменения данных в таблицах, на которых построено это представление.

**Требования:**

* Ровно 1 источник в предложении `FROM`, являющийся таблицей или обновляемым представлением
* Запрос не должен содержать `WITH`, `DISTINCT`, `GROUP BY`, `HAVING`, `LIMIT` или `OFFSET`
* Запрос не должен содержать операторов `UNION`, `INTERSECT` или `EXCEPT`
* select-list запроса не должен содержать агрегатных, оконных, а также функций, возвращающих множества.

```postgresql
WITH [ CASCADED | LOCAL ] CHECK
OPTION
```

Задаёт поведение обновляемым представлениям: проверки, не позволяющие записывать данные, невидимые через представление

* `LOCAL` – проверки выполняются только на самом представлении
* `CASCADED` – проверки выполняются и на самом представлении, и на источнике, и так далее по цепочке обращений

Обновляемые представления – пример 1:

```postgresql
CREATE VIEW universal_comedies AS
SELECT 
    *
FROM 
    comedies
WHERE 
    classification = 'U'
WITH LOCAL CHECK OPTION;
```

Попытка вставить или отредактировать ряд с classification <> 'U' приведёт к ошибке. \
Но при этом вставка или редактирование ряда с kind <> 'Comedy' будет успешной.

Обновляемые представления – пример 2:

```postgresql
CREATE VIEW universal_comedies AS
SELECT 
    *
FROM 
    comedies
WHERE 
    classification = 'U'
WITH CASCADED CHECK OPTION;
```

Попытка вставить или отредактировать ряд с classification <> 'U' или kind <> 'Comedy' приведёт к ошибке.

Столбцы в обновляемом представлении могут быть как обновляемые, так и не обновляемые.

Обновляемые представления – пример 3:

```postgresql
CREATE VIEW comedies AS
SELECT 
    f.*,
    country_code_to_name(f.country_code) AS country,
    (SELECT avg(r.rating) FROM user_ratings r WHERE r.film_id = f.id) AS avg_rating
FROM 
    films f
WHERE 
    f.kind = 'Comedy';
```

Все столбцы таблицы `films` – обновляемые. Столбцы `country` и `avg_rating` – `readonly`.

Если представление не удаётся сделать обновляемым, но в этом есть потребность – используйте `INSTEAD OF` триггер.

Это такая функция, которая будет обрабатывать операции модификации данных – рассмотрим позже.

> Примечание!
>
> Активное использование представлений — это ключевой аспект хорошего проектирования баз данных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые могут меняться по мере развития приложения, за надёжными интерфейсами.
>
> Представления можно использовать практически везде, где можно использовать обычные таблицы. И довольно часто представления создаются на базе других представлений.

### 2. Практическое задание (CTE)

Задание на генерацию значений:

1. Написать запрос на получение суммы чисел от 1 до 100;
2. Написать запрос на получение суммы арифметической прогрессии с шагом в 5, с первым членом 3 и последним 48;
3. Написать запрос на получение суммы геометрической прогрессии с множителем 3 и первым членом 1, содержащей 10
   элементов, используя limit;
4. Написать запрос, который выведет по порядку все дни, начиная с даты первого семинара по Базам Данных («2019-02-04»)
   до сегодня;
5. Написать запрос выводящий все даты, в которые были и будут семинары по Базам Данных, учитывая, что занятия
   начались «2019-02- 04», а закончатся до «2019-06-01» и проводятся в один и тот же день недели;

Задание на построение иерархии:
Пусть дана таблица, в которой содержится иерархия отделов некоторого банка:

```sql
create table public.department (dep_id, par_dep_id, dep_name) as 
select 1, NULL, 'Банк' union
select 2, 1, 'Управление анализа кредитных рисков' union
select 3, 2, 'Отдел риск-менеджмента малого и среднего бизнеса' union 
select 4, 2, 'Отдел риск-менеджмента розничного бизнеса' union 
select 5, 1, 'Департамент ИТ' union
select 6, 5, 'Управление хранилищ данных и отчетности' union 
select 7, 6, 'Отдел очистки и контроля качества данных' union 
select 8, 7, 'Группа администрирования хранилищ данных' union 
select 9, 7, 'Группа контроля качества данных' union
select 10, 5, 'Отдел отчетности и витрин данных' union 
select 11, 5, 'Отдел трансформации и загрузки данных' union 
select 12, 11, 'Группа системного анализа' union
select 13, 11, 'Группа разработки';
```

1. Для каждого `dep_id` вывести строку вида «Группа, Отдел, Управление, ...» к которым он относится;
2. Вывести `dep_id` структурных подразделений 5-го уровня вложенности, например, «Группа системного анализа, Отдел
   трансформации и загрузки данных, Управление хранилищ данных и отчетности, Департамент ИТ, Банк».

### 3. Практическое задание (Views)

Даны две таблицы, с организациями и преподавателями, которые ведут лекции и семинары в МФТИ. Требуется создать эти
таблицы и различные view, связанные с ними.

```sql
create schema topic_7;

create table topic_7.organization as
select 1 as id_org, 'АО Тинькофф Банк' as name_org
union
select 2, 'X5 Retail Group'
union
select 3, 'Сбер';

create table topic_7.teacher (id_teach, last_name, first_name, birth_date, salary_amt, id_org) as
select 1, 'Роздухова', 'Нина', '1992-04-15', 15000.00, 1
union
select 2, 'Меркурьева', 'Надежда', '1995-03-12', 25000.00, 1
union
select 3, 'Халяпов', 'Александр', '1994-09-30', 17000.00, 2
union
select 4, 'Иванов', 'Иван', NULL, 100000.00, 3
union
select 5, 'Петров', 'Петр', NULL, 3000.00, 3;
```

Задание:

1. Создать view – полную копию таблицы teacher;
2. Создать view – копию таблицы teacher, за исключением строк, у которых нет связи с организацией;
3. Создать view с полным списком преподавателей. Вместо id организации выводить ее название. Не включать в представление
   зарплату преподавателя;
4. Создать view с полным списком преподавателей аналогично пункту (3). Фамилию и имя преподавателя объединить в одно
   поле. Поля назвать соответственно русским названиям – «Фамилия Имя», «Дата рождения», «Название организации»;
5. Написать вставку записи (на своё усмотрение) во view из пункта (1). Проверить, что новая запись появилась в исходной
   таблице;
6. Написать удаление записи, вставленной в пункте (5), через view из пункта (1). Проверить, что запись удалилась из
   исходной таблицы;
7. Обновить дату рождения и у преподавателя id_teach = 4 (на любую) через view из пункта (1);
8. Обновить id_org у преподавателя с id_teach = 4 на NULL через view из пункта (2). Проверить, что преподаватель пропал
   view из пункта (2);
9. Пересоздать view и пункта (2) с условием [with local check option]. Попробовать проделать те же манипуляции, что в
   пункте (8) на преподавателе id_teach = 5.

---

### Полезные ссылки

 * [Запросы `WITH` (Общие табличные выражения)](https://postgrespro.ru/docs/postgresql/14/queries-with)
 * [Возврат данных из изменённых строк](https://postgrespro.ru/docs/postgresql/14/dml-returning)
 * [Представления](https://postgrespro.ru/docs/postgresql/14/sql-createview)
