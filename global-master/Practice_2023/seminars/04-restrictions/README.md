## Тема 4. Ключи, ограничения

### 1. Теоретическая справка (ключи)

**Потенциальный ключ** – подмножество атрибутов отношения, удовлетворяющее требованиям уникальности и минимальности:
* *Уникальность*: нет и <ins>не может быть</ins> двух кортежей данного отношения, в которых значения этого подмножества атрибутов совпадают;
* *Минимальность*: в составе потенциального ключа отсутствует меньшее подмножество атрибутов, удовлетворяющее условию уникальности;
* Типы:
    * *простой* (состоит ровно из одного атрибута)
    * *составной* (состоит из двух и более атрибутов)

**Первичный ключ** *(Primary key, PK)* — любой из потенциальных ключей, выбранный в качестве основного; выбирают в качестве первичного такой ключ, который занимает меньше места при хранении и который не утратит свою уникальность со временем. (потенциальный ключ существует всегда, даже если включает в себя все атрибуты отношения) **Альтернативными ключами** называются потенциальные ключи, не выбранные в качестве первичного.

Типы:
* *естественный* (основанный на уже существующем поле)
* *интеллектуальный* (основанный на естественном ключе путем добавления дополнительного поля)

**Суррогатный ключ** — это дополнительное служебное поле, которое добавляется к уже имеющимся информационным полям таблицы, единственное предназначение которого – служить первичным ключом. (значение генерируется искусственно).
* *Достоинства:*
    * *Гарантированная уникальность:* т.к. значение генерируется автоинкрементом, повторение значений исключено.
    * *Память:* может быть меньше, чем первичный ключ из отношения.
    * *Неизменность:* заполнили одним значением раз и навсегда (кроме экстраординарных ситуаций)
    * *Гибкость:* т.к. такой ключ не несет никакой информативной нагрузки, его можно свободно заменить.
    * *Проще программировать:* позволяет не завязывать на структуре конкретной БД. Особенно удобно для языков со статической типизацией.
    * *Эффективность:* удобнее при создании ссылок на другие таблицы.
* *Недостатки:*
    * *Уязвимость генераторов:* по номерам ключей возможно узнать число новых записей за определенный период времени.
    * *Неинформативность:* усложняется ручная проверка БД
    * *Склоняет администратора пропустить нормализацию:* вместо того, чтобы разбить отношение на несколько отношений и аккуратно учесть все связи, велик соблазн просто создать суррогатный ключ. (Примечание: о нормализации подробнее узнаем в следующей серии)
    * *Вопросы оптимизации:* необходимость поддержания и суррогатного, и естественного ключей.
    * Невольная привязка разработчика к поведению генератора ключей в конкретной СУБД
    * Сами выбираем алгоритм генерации → можно узнать свойства нашей модели данных по ключам, также можно ошибиться, придумывая алгоритм генерации.


Пусть R<sub>1</sub> и R<sub>2</sub> – две переменные отношения, не обязательно различные. **Внешним ключом FK (Foreign key)** в R<sub>2</sub> является подмножество атрибутов переменной R2 такое, что выполняются следующие требования:
* В переменной отношения R<sub>1</sub> имеется потенциальный ключ PK такой, что PK и FK совпадают с точностью до переименования атрибутов (FK из R<sub>2</sub> является PK из R<sub>1</sub>)
* В любой момент времени каждое значение FK в текущем значении R<sub>2</sub> идентично значению PK в некотором кортеже в текущем значении R<sub>1</sub>. Иными словами, в любой момент времени множество всех значений FK в R<sub>2</sub> является подмножеством значений PK в R<sub>1</sub>.

* *Родительское (главное/целевое) отношение* — отношение R<sub>1</sub>, содержащее потенциальный ключ.
* *Дочернее (подчиненное) отношение* — отношение R<sub>2</sub>, содержащее в себе ссылку на сущность, в которой находятся нужные нам атрибуты. (содержащее в себе внешний ключ)

#### 1.1. Ссылочная целостность и немного лирики

**Ссылочная целостность** – это необходимое качество реляционной базы данных, заключающееся в отсутствии в любом её отношении внешних ключей, ссылающихся на несуществующие кортежи.

База данных обладает свойством ссылочной целостности, когда для любой пары связанных внешним ключом отношений в ней условие ссылочной целостности выполняется.

**В реальных бд ссылочная целостность не всегда поддерживается.**

Нарушения ссылочной целостности могут появиться в ходе эксплуатации по ряду причин:
* Иногда разработчики просто пропускают шаг создания ссылок
* Некорректная работа прикладного программного обеспечения:
    * Неполная запись объектов (данные объекта размещаются в записях нескольких таблиц, а программа не записывает какую-то из них).
    * Некорректная правка ссылки (значение внешнего ключа изменяется на такое, которому не соответствует ни одна запись в связанной таблице)
    * Правка первичного ключа без каскадного обновления (в таблице, на которую есть ссылки, правится первичный ключ, но при этом внешние ключи в связанных с ней таблицах остаются без изменения)
    * Удаление записи без каскадного обновления (Из таблицы удаляется запись, на которую имеются ссылки по внешним ключам других таблиц, при этом в связанных записях внешние ключи не меняются. В результате все ссылающиеся на нее записи других таблиц становятся некорректными)
* Сбои в работе системного программного обеспечения и оборудования:
    * Если необходимо внести данные об объекте в несколько страниц, то в ходе транзакции ссылочная целостность будет нарушена — в часть таблиц информация уже внесена, а в часть — еще нет. Так, если операция будет прервана до завершения по каким-то техническим причинам, то часть добавленных записей останется с некорректными ссылками.
* Иногда же на практике при отсутствии какой-то информации об объекте ключ остается пустым (имеет значение NULL). И хотя с точки зрения теории это недопустимо, легенда гласит, что на практике это иногда удобно в применении.

### 2. Теоретическая справка (ограничения)

1. `NOT NULL` – значение всегда известно, недопустимо значение `NULL`.
2. `UNIQUE` – значения в столбце должны быть уникальны.
3. `PRIMARY KEY` – первичный ключ таблицы. В некоторых СУБД требуется дополнительно ограничивать `NOT NULL` (чаще выставлено по дефолту; также заведомо является `UNIQUE`)
4. `FOREIGN KEY` – внешний ключ, необходима ссылка на другую таблицу.
5. `CHECK` – проверка на соответствие определенному критерию.
6. `DEFAULT` – значение по умолчанию; используется, если пользователь не задал значения.

#### 2.1. Синтаксис добавления ограничений

1. `NOT NULL`
```postgresql
CREATE TABLE PERSON (
    ID         INTEGER      NOT NULL,
    LAST_NAME  VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(255) NOT NULL,
    AGE        INTEGER
);
```

2. `UNIQUE`
```postgresql
CREATE TABLE PERSON (
    ID         INTEGER      NOT NULL UNIQUE,
    LAST_NAME  VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(255) NOT NULL,
    AGE        INTEGER
);

ALTER TABLE PERSON ADD UNIQUE (ID);

ALTER TABLE PERSON
ADD CONSTRAINT UC_Person UNIQUE (ID, LAST_NAME);

ALTER TABLE PERSON
DROP CONSTRAINT UC_Person;
```

3. `PRIMARY KEY`
```postgresql
CREATE TABLE PERSON (
    ID         INTEGER      PRIMARY KEY,
    LAST_NAME  VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(255) NOT NULL,
    AGE        INTEGER
);

ALTER TABLE PERSON ADD PRIMARY KEY (ID);

------------------------------------------

CREATE TABLE PERSON (
    ID         INTEGER,
    LAST_NAME  VARCHAR(255),
    FIRST_NAME VARCHAR(255) NOT NULL,
    AGE        INTEGER,
    CONSTRAINT PK_Person PRIMARY KEY (ID, LAST_NAME)
);

ALTER TABLE PERSON
ADD CONSTRAINT PK_Person PRIMARY KEY (ID, LAST_NAME);

ALTER TABLE PERSON
DROP CONSTRAINT PK_Person;
```

4. `FOREIGN KEY`
```postgresql
CREATE TABLE ORDER (
    ORDER_ID     INTEGER,
    ORDER_NUMBER INTEGER NOT NULL,
    PERSON_ID    INTEGER,
    
    PRIMARY KEY (ORDER_ID),
    CONSTRAINT FK_PersonOrder FOREIGN KEY (PERSON_ID) REFERENCES PERSON(PERSON_ID)
);

ALTER TABLE ORDER ADD CONSTRAINT FK_PersonOrder
FOREIGN KEY (PERSON_ID) REFERENCES PERSON(PERSON_ID);

ALTER TABLE ORDER DROP CONSTRAINT FK_PersonOrder;

------------------------------------------

CREATE TABLE ORDER (
    ORDER_ID     INTEGER PRIMARY KEY,
    ORDER_NUMBER INTEGER NOT NULL,
    PERSON_ID    INTEGER REFERENCES PERSON(PERSON_ID)
);

ALTER TABLE ORDER
ADD FOREIGN KEY (PERSON_ID) REFERENCES PERSON(PERSON_ID);
```

При определении FK у нас должно совпадать количество атрибутов в обеих таблицах, которые мы "мэтчим". Также в таблице, для которой атрибуты являются PK, должны быть заданы соответствующие ограничения – иначе будет ошибка `there is no unique constraint matching given keys for referenced table`.

<span>&ensp;&nbsp;</span>4<span>&frac34;</span>. Поддержание ссылочной целостности

* `CASCADE` – при удалении / изменении строки главной таблицы соответствующая запись дочерней таблицы также будет удалена / изменена.

* `RESTRICT` – cтрока не может быть удалена / изменена, если на нее имеется ссылка;  Значение не может быть удалено / изменено, если на него есть ссылка.

* `NO ACTION`

    * Имеет сходства с `RESTRICT`, но проверка происходит в конце транзакции;
    * Для разницы с RESTRICT нужно явно прописывать в транзакции выражение ([`SET CONSTRAINTS`](https://www.postgresql.org/docs/current/sql-set-constraints.html))

    ```postgresql
    SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE }
    ```

* `SET NULL` – при удалении записи главной таблицы, соответствующее значение дочерней таблицы становится `NULL`.

* `SET DEFAULT` – аналогично `SET NULL`, но вместо значения `NULL` устанавливается некоторое значение по умолчанию.

```postgresql
CREATE TABLE ORDER (
    ORDER_ID     INTEGER,
    ORDER_NUMBER INTEGER NOT NULL,
    PERSON_ID    INTEGER,
    
    PRIMARY KEY (ORDER_ID),
    CONSTRAINT FK_PersonOrder FOREIGN KEY (PERSON_ID)
        REFERENCES PERSON(PERSON_ID)
            ON DELETE RESTRICT
            ON UPDATE RESTRICT
);
```

5. `CHECK`
```postgresql
CREATE TABLE PERSON (
    ID         INTEGER      NOT NULL,
    LAST_NAME  VARCHAR(255) NOT NULL,
    FIRST_NAME VARCHAR(255) NOT NULL,
    AGE        INTEGER      CHECK (AGE >= 18)
);

ALTER TABLE PERSON ADD CHECK (AGE >= 18);

------------------------------------------

CREATE TABLE PERSON (
    ID          INTEGER      NOT NULL,
    LAST_NAME   VARCHAR(255) NOT NULL,
    FIRST_NAME  VARCHAR(255) NOT NULL,
    AGE         INTEGER,
    CITY        VARCHAR(255),
    CONSTRAINT CHK_Person CHECK (AGE >= 18 AND CITY = 'Moscow')
);

ALTER TABLE PERSON ADD CONSTRAINT CHK_Person
CHECK (AGE >= 18 AND CITY = 'Moscow');

ALTER TABLE PERSON DROP CONSTRAINT CHK_Person;
```

6. `DEFAULT`
```postgresql
CREATE TABLE ORDER (
    ORDER_ID     INTEGER PRIMARY KEY,
    ORDER_NUMBER INTEGER NOT NULL,
    ORDER_DATE   DATE    DEFAULT now()::date
);

ALTER TABLE ORDER;
ALTER COLUMN ORDER_DATE DROP DEFAULT;
```

Есть возможность посмотреть все **имеющиеся в базе ограничения**:

```postgresql
-- Список колонок, попадающих под ограничение:
SELECT * FROM information_schema.constraint_column_usage;

-- Все имеющиеся в базе ограничения:
SELECT * FROM information_schema.table_constraints;

-- Уникальные и ключевые (PK, FK) поля таблиц
SELECT * FROM information_schema.key_column_usage;

-- Информация по ограничениям с типом `CHECK`
SELECT * FROM information_schema.check_constraints;

-- Информация по ограничениям с типом `DEFAULT` и `NOT NULL`
SELECT * FROM information_schema.columns;
```

### Практика

1. Создать схему `seminar_4`;
2. Создать в этой схеме таблицу `cast` с ненулевыми полями `name`  и  `surname`, а также `birth_date` типа `date`;
3. Запустить следующие операции вставки:
    
    ```sql
    insert into seminar_4.cast values
        ('Милли', 'Олкок', '2000-04-11'),
        ('Мэтт', 'Смит', '1982-10-28'),
        ('Эмма', 'Д''Арси', '1992-06-27'),
        ('Оливия', 'Кук', '1993-12-27'),
        ('Эмили', 'Кэри', '2003-04-30');
    insert into seminar_4.cast values
        ('Юэн', 'Митчелл'),
        ('Пэдди', 'Консидайн'),
        ('Ив', 'Бест');
    ```
    
4. Добавить `primary key` -колонку `id` типа `serial` ([документация](https://postgrespro.ru/docs/postgresql/9.6/datatype-numeric)). Как называется такой вид ключа?
5. Добавить ограничение на колонку  `birth_date` – значение по умолчанию равно `date ‘1900-01-01’`.
Выведите все строки таблицы, чтобы проверить значения колонок `date` и `id`. (В случае использования IDE также можно в схеме базы посмотреть на то, как выглядит схема таблицы)
6. Удалите все строки с пустой датой рождения, а после запустите вторую вставку. Снова выведите все строки таблицы и обратите внимание на колонки `date` и `id`.
7. Создайте в схеме `seminar_4` таблицу `characters` с ненулевым полем `name`,  внешним ключом  `actor_id`, ссылающимся на поле `id` из таблицы `seminar_4.cast`,  текстовым полем `comment`, полем `sex`, которое может принимать значения `'male'` или `'female'`.
8. Запустите следующие операции вставки в таблицу:
    
    ```sql
    insert into seminar_4.characters (name, actor_id, comment, sex) values
        ('Рейнира Таргариен', 1, 'Юная принцесса', 'female'),
        ('Деймон Таргариен', 2, '', 'male'),
        ('Рейнира Таргариен', 3, 'Принцесса / королева', 'female'),
        ('Алисента Хайтауэр', 4, 'Королева', 'female'),
        ('Алисента Хайтауэр', 5, 'Юная леди / королева', 'female'),
        ('Эймонд Таргариен', 9, 'Принц', 'male');
    ```
    
9. Попробуйте добавить в таблицу:
    1. строку с `actor_id`, который не встречается в таблице `seminar_4.cast`;
    2. строку с пустым полем `sex`: `('Эймонд Таргариен', 9)`;
    3. строку с пустым полем `actor_id`: `('Эймонд Таргариен')`;
10. Какое поле или набор полей подойдут на роль первичного ключа в этой таблице? Добавьте соответствующее ограничение, предварительно удалив строки, которые мешают это сделать. (В случае использования IDE также можно в схеме базы посмотреть на то, как теперь выглядит схема таблицы)
11. Удалите из таблицы `seminar_4.cast` актеров, игравших юных героев (содержащих в комментарии слово ‘юный’ или ‘юная’), так, чтобы все их герои также исчезли из таблицы `seminar_4.characters`. Возможно придется удалить созданное ограничение на внешний ключ и задать новое.