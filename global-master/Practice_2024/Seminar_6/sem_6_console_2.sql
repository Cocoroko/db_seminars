-- Создаем новое подключение с username = post2 и password = password

--1. Создать схему topic_6:


--Создать таблицу:


--2. Открыть новую транзакцию в явном виде. Запустить операцию вставки


--Не завершая транзакцию, проверить, что данные в таблицу вставились. Обратить внимание на значение в поле my_id.


--3. В новой консоли написать запрос на получение всех строк таблицы, созданной в п.2. Объясните, почему так вышло.
--Закоммитьте изменения в консоли 1.

select * from topic_6.test_table; -- Не видим изменения в таблице, так как не завершена транзакция в первой консоли


--4.В обеих консолях откройте новые транзакции.

begin;
--Напишите в первой консоли апдейт к единственной строке таблицы. Проверьте, что первая транзакция видит изменения.

--Во второй консоли запустите операцию апдейта к той же строке. Подумайте, что произошло и почему?

update topic_6.test_table set my_text_field = 'test_value second console';  -- Консоль ожидает окончания транзакции

--Сохраните изменения в первой консоли. Что произошло со второй консолью?

-- Изменения прошли, скрипт отработал

--Сохраните изменения во второй консоли.

commit;

select * from topic_6.test_table;

--6. Повторите предыдущее упражнение с использованием уровня repeatable read. Что произошло при попытке закоммитить
--изменения первой открытой транзакцией? Откатите обе транзакции.

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

update topic_6.test_table set my_text_field = 'test_value6 second';  --Ловит ошибку при попытке коммита

rollback;

--7. Для получения дефолтного значения уровня изолированности транзакций в вашем постгрес воспользуйтесь командой:



SHOW default_transaction_isolation;
--Объясните разницу в поведении транзакций в задачах 6 и 7, воспользовавшись новым знанием.

--8. Повторите задачу 5, используя оператор вставки данных, а не обновления, по аналогии с п.3. Посмотрите на значение в
--поле my_id после вставки второй транзакцией.


begin;

insert into topic_6.test_table (my_text_field)
values
('test 8 second');  

select * from topic_6.test_table;  -- my_id = 3, пропустив 2, т.к. вставка была еще и в первой консоли и сервер ее увидел

rollback;

--9. В обеих консолях откройте новые транзакции уровня serializable

BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

--Первой транзакцией считайте данные из таблицы.

--Второй транзакцией осуществите вставку в таблицу новых данных. И сразу же примените изменения.

insert into topic_6.test_table (my_text_field)
values
('test 9 second'); 

commit;

--Снова считайте данные первой транзакцией. Что произошло?

--Попробуйте добавить в таблицу данные с использованием первой транзакции. Что произошло? Откатите изменения.


--10. Откройте новую транзакцию в любой консоли, уровень изолированности не имеет значения.


--Добавьте в таблицу несколько строк.

--Создайте точку останова (savepoint) и посмотрите на значения в таблице.

--Снова добавьте в таблицу несколько строк, создайте точку останова и посмотрите на строки в таблице.

--Добавьте в таблицу еще одну строк и посмотрите на таблицу.

--Откатитесь ко второй точке останова и посмотрите на данные.

--Откатитесь к первой точке останова и посмотрите на данные.

--Откатите всю транзакцию.